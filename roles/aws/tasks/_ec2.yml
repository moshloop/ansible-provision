  - name: setting az for "{{inventory_hostname}}"
    set_fact: az="{{region}}{{inventory_hostname | zone(subnets_count, region) }}"

  - set_fact: query="instances[?tags.Name=='{{inventory_hostname}}' && state == 'running']"

  - set_fact: "ec2_instances={{ec2_facts| json_query(query) }}"

  - set_fact: "ec2_instance={{ec2_instances[0]}}"
    when: ec2_instances | length > 0

  - set_fact: ip="{{ ec2_instance['private_ip_address'] | default('') }}"
    when: ec2_instance is defined

  - debug: var=ec2_instance verbosity=1
    when: ec2_instance is defined

  - include_tasks: _ami.yml

  - debug: var=sg_groups verbosity=1

  - set_fact:
      security_group_ids: []
      security_groups: "{{ security_groups | default([]) }}"

  - name: merge security group names
    set_fact:
      security_groups: "{{security_groups}} + ['{{role}}-{{purposeId }}']"
    when: purposeId is defined and role != purposeId


  - debug:
      msg: "{{inventory_hostname}}|{{ip | default('')}}/{{ami}}/{{az}} -> ({{security_groups}}) updates(ami: {{ami_update}}, userData: {{userData_update}}, boot_disk: {{boot_disk_update}}, tags: {{tags_update}}), old={{ec2_instance.image_id | default('NEW') }}"

  - name: lookup security group id by name
    set_fact:  security_group_ids="{{security_group_ids + [sg_groups.get(item | lower,'')] }}"
    with_items: "{{security_groups}}"
    when: sg_groups is defined

  - set_fact:
      security_group_ids: "{{ security_group_ids | reject('equalto', '') | list }}"

  - name: set subnet
    set_fact: subnet="{{all_subnets | find_subnets(subnet_name, az) |  map(attribute='id') | first}}"

  - include_tasks: _cloud_init.yml

  - name: Looking up existing tags to prevent update
    block:
      - set_fact: tags="{{ tags | combine(ec2_instance.tags | reject_startswith('aws:')) }}"
    when: ec2_instance is defined and (tags_update is defined and tags_update == 'false')
    delegate_to: localhost

  - set_fact:
      tags: "{{all_tags | combine(tags) }}"

  - ec2_vol_facts:
      region: "{{region}}"
      filters:
        volume-id: "{{ (ec2_instance.block_device_mapping  | selectattr('device_name', 'equalto', '/dev/sda1') | first).volume_id }}"
    register: boot_disk
    when: ec2_instance is defined and (boot_disk_update is defined and boot_disk_update == 'false')

  - debug: var=boot_disk verbosity=1
    when: boot_disk is defined

  - name: Looking up boot disk size to prevent re-creation
    set_fact:
      boot_disk_size: "{{ boot_disk.volumes[0].size }}"
      boot_disk_type: "{{ boot_disk.volumes[0].type }}"
    when: boot_disk is defined and boot_disk.volumes is defined and (boot_disk_update is defined and boot_disk_update == 'false')
    delegate_to: localhost

